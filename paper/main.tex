%
%  $Author: ienne $
%  $Date: 1995/09/15 15:20:59 $
%  $Revision: 1.4 $
%

% \documentclass[10pt,journal,cspaper,compsoc]{IEEEtran}   %%%tc version
\documentclass[10pt, conference]{IEEEtran}
%\documentclass[conference,compsoc]{IEEEtran}
%\documentclass[10pt, conference]{IEEEtran}
%\documentclass[times, 10pt,onecolumn]{article}
\usepackage{amsmath, amssymb, enumerate}
\usepackage{semantic}
\usepackage{soul}
\usepackage{listings}

%%%%%%%%%%%%%%%% page control%%%%%%%%%%%%%%%%%
%\usepackage[margin=0.75in]{geometry}

%\linespread{0.991}  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% this is really useful
%\usepackage{cite}
\usepackage{fancybox}
\usepackage{amsfonts}
%\usepackage{algorithm}
%\usepackage[noend]{algorithmic}
\usepackage[usenames]{color}
%\usepackage{colortbl}
%\usepackage[ figure, boxed, vlined]{algorithm2e}
%\usepackage[linesnumbered,vlined]{algorithm2e}
%\usepackage[lined,boxed]{algorithm2e}
\usepackage{listings}

\usepackage[linesnumbered,vlined]{algorithm2e}
\usepackage{graphicx}
\usepackage{times}
\usepackage{psfrag}
\usepackage{subfigure}
\usepackage{caption}
%\usepackage{subcaption}
\usepackage{multirow}
%\usepackage{setspace}
%\usepackage{listings}
\usepackage{epsfig}
%\usepackage{epstopdf}
%\usepackage[font=small,labelfont=bf]{caption}
% \usepackage{url}
\usepackage[hyphens]{url}

\usepackage{color}
\def\fixme#1{\typeout{FIXED in page \thepage : {#1}}
%\bgroup \color{red}{} \egroup}
\bgroup \color{red}{[FIXME: {#1}]} \egroup}

\lstset{breaklines=true, basicstyle=\ttfamily\fontsize{6}{7}\selectfont, escapeinside={(*@}{@*)}}

%\usepackage[pdftex]{hyperref}
\usepackage{rotating,tabularx}

\interfootnotelinepenalty=10000

%% Define a new 'leo' style for the package that will use a smaller font.
\makeatletter
\def\url@leostyle{%
  \@ifundefined{selectfont}{\def\UrlFont{\sf}}{\def\UrlFont{\small\ttfamily}}}
\makeatother

%\documentstyle[times,art10,twocolumn,latex8]{article}

%-------------------------------------------------------------------------
% take the % away on next line to produce the final camera-ready version
\pagestyle{plain}
%\thispagestyle{empty}
%\pagestyle{empty}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}


%% remaining budget share, used in task stall section.
\newcommand{\bottomrule}{\hline}
\newcommand{\toprule}{\hline}
\newcommand{\midrule}{\hline}

\setlength\extrarowheight{1.5pt}
\setlength{\tabcolsep}{1pt}

\newcommand{\ttt}{\texttt}
\newcommand{\rarr}{\rightarrow}
\newcommand{\sarr}{\leadsto}
%-------------------------------------------------------------------------
\begin{document}

\title{A Domain Specific Language for SpectreGuard}
\author{David Young\\
d063y800@ku.edu\\
University of Kansas, USA\\
}

\maketitle
\thispagestyle{empty}
\begin{abstract}

  A Spectre mitigation strategy in the form of a mechanism for marking variables
  as "non-speculative" was developed in \cite{SpectreGuard}. In this paper, we
  develop an embedded domain specific language (EDSL) in Haskell to provide
  support for this feature, with a backend that generates C code. The static
  type system of Haskell is used so that many basic forms of copying secret
  variables to public variables are disallowed. Additionally, a static analysis
  was developed which will detect some cases of secret variables leaking to
  public variables via control flow constructs.

\end{abstract}

%-------------------------------------------------------------------------

\section{Introduction}
Introduction goes here.

\section{Background}
Cite a paper. % \cite{barroso2009datacenter}.

Cite multiple papers. % \cite{banga99resourcecontainers,barroso2009datacenter}

\section{Syntax}
A correspondence between the syntax of the EDSL, which is inherited from
Haskell, and the C language is given in Fig. \ref{fig:Syntax}. In the right column, an
overline indicates that the transformation from EDSL to C is recursively
performed to the expression or command underneath the overline.

This also outlines procedure that the C code generator uses.

\begin{figure}[h]
\begin{tabular}{|l|l|}
  \hline
  EDSL syntax & C syntax \\
  \hline
  \begin{lstlisting}
  v <- decl x
  \end{lstlisting}
  & \begin{lstlisting}
  int v = x;
  \end{lstlisting}\\

  \hline
  \begin{lstlisting}
  v <- allocPublic @Int n
  \end{lstlisting}
  & \begin{lstlisting}
  int v[n];
  \end{lstlisting}\\

  \hline
  \begin{lstlisting}
  v <- allocPrivate @Int n
  \end{lstlisting}
  & \begin{lstlisting}
  int v[n] __attribute__((__nospec__));
  \end{lstlisting}\\

  \hline
  \begin{lstlisting}
  arrA .= arrB
  \end{lstlisting}
  & \begin{lstlisting}
  memcpy(arrA, arrB, sizeof(arrA));
  \end{lstlisting}\\

  \hline
  \begin{lstlisting}
  i .= j
  \end{lstlisting}
  & \begin{lstlisting}
  i = j;
  \end{lstlisting}\\

  \hline
  \begin{lstlisting}
  arr ! i
  \end{lstlisting}
  & \begin{lstlisting}
  arr[i]
  \end{lstlisting}\\

  \hline
  \begin{lstlisting}
  x <? y
  \end{lstlisting}
  & \begin{lstlisting}
  x < y
  \end{lstlisting}\\

  \hline
  \begin{lstlisting}
  while cond body
  \end{lstlisting}
  & \begin{lstlisting}
  while ((*@$\overline{\ttt{cond}}$@*)) { (*@$\overline{\ttt{body}}$@*) }
  \end{lstlisting}\\

  \hline
  \begin{lstlisting}
  if cond t f
  \end{lstlisting}
  & \begin{lstlisting}
  if ((*@$\overline{\ttt{cond}}$@*)) { (*@$\overline{\ttt{t}}$@*) } else { (*@$\overline{\ttt{f}}$@*) }
  \end{lstlisting}\\

  \hline
  \begin{lstlisting}
  for init
    (\i ->
      (cond, update, body))
  \end{lstlisting}
  & \begin{lstlisting}
  for (int i = (*@$\overline{\ttt{init}}$@*); (*@$\overline{\ttt{cond}}$@*); (*@$\overline{\ttt{update}}$@*))
    { (*@$\overline{\ttt{body}}$@*) }
  \end{lstlisting}\\


  \hline
\end{tabular}
\caption{Syntax of the EDSL vs C syntax}
\label{fig:Syntax}
\end{figure}

\section{Sensitivity Types}
The Haskell type system is leveraged to perform a basic static consistency check of the sensitivities
of variables, so that a variable does not get assigned to a variable of a different sensitivity. This
is done by making the \verb|Expr| type constructor take a phantom type argument~\cite{Phantom}. The
logical inference rules corresponding to this check are given in Fig. \ref{fig:SensTypes}. An introduction
to this style of inference rule system, with many examples and applications in the study of programming languages, is given in \cite{HarperFoundations}.

Singletons~\cite{SingletonsPaper} are used to preserve this type level at runtime, so that the
code generator can generate SpectreGuard annotations where appropriate.

In Fig. \ref{fig:SensTypes}, it is assumed that $\tau$ and $\sigma$ are given by the
following grammar:
\begin{gather*}
  \sigma ::= \ttt{Public}\;|\;\ttt{Secret}\\
  \tau ::= \ttt{Int}\;|\;\ttt{Ptr}\;\tau\\
  \alpha ::= \ttt{Cmd ()}\;|\;\ttt{Cmd (Expr $\sigma$ $\tau$)}
\end{gather*}

A typing judgement is expressed with the syntax

\begin{equation*}
  \ttt{x :: $\beta$}
\end{equation*}

where \ttt{x} is some expression or command in the EDSL. This judgement means
that \ttt{x} has type $\beta$. This is also the same syntax used by Haskell, and by extension
the EDSL, to explicitly specify the type of any expression when necessary or desired.


\begin{figure}[h]
  \centering
\resizebox{0.68\linewidth}{!}{
\begin{minipage}{\linewidth}
  \centering
\begin{gather*}
  \inference{}{\ttt{Public :: Sensitivity}}\\
\\
  \inference{}{\ttt{Secret :: Sensitivity}}\\
\\
  \inference{n \in \mathbb{N}}{\ttt{$n$ :: Int}}\\
\\
  \inference{%
    \Gamma \vdash \ttt{x :: Int}
    & \Gamma \vdash \ttt{y :: Int}}
    {\Gamma \vdash \ttt{x + y :: Int}}\\
  \\
  \inference{%
    \Gamma \vdash \ttt{x :: Expr $\sigma$ Int}
    & \Gamma \vdash \ttt{y :: Expr $\sigma$ Int}}
    {\Gamma \vdash \ttt{x <? y :: Expr $\sigma$ Bool}}\\
  \\
  \inference{%
    \Gamma \vdash \ttt{a :: Expr $\sigma$ (Ptr $\tau$)}
    & \Gamma \vdash \ttt{i :: Expr $\sigma$ Int}}
    {\Gamma \vdash \ttt{a ! i :: Expr $\sigma$ $\tau$}}\\
  \\
  \inference{\Gamma \vdash \ttt{n :: Int}}{\Gamma \vdash \ttt{allocPublic @$\tau$ n :: Cmd (Expr Public (Ptr $\tau$))}}\\
\\
  \inference{\Gamma \vdash \ttt{n :: Int}}{\Gamma \vdash \ttt{allocSecret @$\tau$ n :: Cmd (Expr Secret (Ptr $\tau$))}}\\
\\
  \inference{\Gamma \vdash \ttt{x :: $\tau$}}{\Gamma \vdash \ttt{decl x :: Cmd (Expr Public $\tau$)}}\\
\\
  \inference{%
    \Gamma \vdash \ttt{x :: Expr $\sigma$ $\tau$}
    & \Gamma \vdash \ttt{y :: Expr $\sigma$ $\tau$}}
    {\Gamma \vdash \ttt{x .= y :: Cmd ()}}\\
  \\
  \inference{%
    \Gamma \vdash \ttt{cond :: Expr $\sigma$ Bool}
    &\Gamma \vdash \ttt{t :: $\tau$}
    &\Gamma \vdash \ttt{f :: $\tau$}}
    {\Gamma \vdash \ttt{ifThenElse cond t f :: Cmd ()}}\\
  \\
  \inference{%
    \Gamma \vdash \ttt{cond :: Expr $\sigma$ Bool}
    & \Gamma \vdash \ttt{body :: Cmd $\alpha$}}
    {\Gamma \vdash \ttt{while cond body :: Cmd ()}}\\
  \\
  \inference{%
    \Gamma \vdash \ttt{init :: Expr $\sigma$ $\tau$}\\
    \Gamma \vdash \ttt{fn :: Expr $\sigma$ $\tau$ $\rarr$ (Expr $\sigma$ Bool, Cmd (), Cmd ())}
    }{\Gamma \vdash \ttt{for init fn :: Cmd ()}}\\
  \\
  \inference{%
    \Gamma \vdash \ttt{c :: Cmd (Expr $\sigma$ $\tau$)}
    & \ttt{x} \notin dom(\Gamma)
    \\ \Gamma \vdash \ttt{($\lambda$ x $\rarr$ body) :: Expr $\sigma$ $\tau$ $\rarr$ Cmd $\alpha$}
  }{%
    \Gamma \vdash \ttt{(\textbf{do} \{ x <- c; body \}) :: Cmd $\alpha$}
  }
\end{gather*}
\end{minipage}}
  \caption{Typing rules for sensitivity types}
\label{fig:SensTypes}
\end{figure}

...

\section{Information Flow Analysis}
\begin{figure}[h]
  \centering
\resizebox{0.68\linewidth}{!}{
\begin{minipage}{\linewidth}
  \centering
\begin{gather*}
  \inference{%
    \Delta;\Gamma \vdash \ttt{x :: $\tau$}
    \\ \Delta;\Gamma \vdash \ttt{k :: Expr Public $\tau$ $\rarr$ Cmd $\alpha$}
    \\ \Delta;\Gamma\vdash A(\ttt{decl v >>= ($\lambda$x $\rarr$ k)})
    }
    {%
      \Delta,Pub(x);\Gamma \vdash A(\ttt{k})
    }\\
    \\
  \inference{%
    \Delta;\Gamma \vdash \ttt{x :: Expr Public $\tau$}
    & \Delta;\Gamma \vdash \ttt{y :: Expr Public $\tau$}
    \\ \Delta;\Gamma \vdash \ttt{k :: () $\rarr$ Cmd $\alpha$}
    & \Delta;\Gamma \vdash A(\ttt{(x .= y) >>= k})
    \\ \Delta;\Gamma \vdash L(\ttt{x}) \neq \varnothing
    }
    {%
      \Delta;\Gamma \vdash \ttt{x} \sarr L(\ttt{x})
    }\\
  \\
  \inference{%
    \Delta;\Gamma \vdash \ttt{cond :: Expr Bool}
    & \Delta;\Gamma \vdash \ttt{body :: Cmd $\alpha$}
    \\ \Delta;\Gamma \vdash A(\ttt{while cond body})
    & \Delta;\Gamma \vdash s \in Secrets(\ttt{cond})
    \\ \Delta;\Gamma \vdash Pub(\ttt{x})
    }
    {%
      \Delta, s \in L(\ttt{x});\Gamma \vdash A(\ttt{body})
    }\\
  \\
  \inference{%
    \Delta;\Gamma \vdash \ttt{cond :: Expr Bool}
    \\ \Delta;\Gamma \vdash \ttt{t :: Cmd $\alpha$}
    & \Delta;\Gamma \vdash \ttt{f :: Cmd $\alpha$}
    \\ \Delta;\Gamma \vdash A(\ttt{if cond t f})
    & \Delta;\Gamma \vdash s \in Secrets(\ttt{cond})
    \\ \Delta;\Gamma \vdash Pub(\ttt{x})
    }
    {%
      \Delta, s \in L(\ttt{x});\Gamma \vdash A(\ttt{t})
    }\\
  \\
  \inference{%
    \Delta;\Gamma \vdash \ttt{cond :: Expr Bool}
    \\ \Delta;\Gamma \vdash \ttt{t :: Cmd $\alpha$}
    & \Delta;\Gamma \vdash \ttt{f :: Cmd $\alpha$}
    \\ \Delta;\Gamma \vdash A(\ttt{if cond t f})
    & \Delta;\Gamma \vdash s \in Secrets(\ttt{cond})
    \\ \Delta;\Gamma \vdash Pub(\ttt{x})
    }
    {%
      \Delta, s \in L(\ttt{x});\Gamma \vdash A(\ttt{f})
    }\\
  \\
  \inference{%
    \Delta;\Gamma \vdash v \in L(\ttt{x})
    }
    {%
      \Delta;\Gamma \vdash L(\ttt{x}) \neq \varnothing
    }
\end{gather*}
\end{minipage}}
  \caption{Information flow analysis rules which define the relation $\sarr$}
\label{fig:FlowRules}
\end{figure}
...
\section{Examples}
...
% \section{Your System}
% ...
% \section{Evaluation}
% ...

\section{Future Work}
A further investigation into the tradeoffs and possible additional features of
the information flow analysis is likely to be useful. This could provide a more
accurate and succinct picture to programmers of where leaks are occurring, or
potentially occurring. It is possible that some of these other leak conditions
could be incorporated into the type system, by exploiting the dependent type
features enabled by singletons~\cite{SingletonsPaper} and, in the future, by Dependent Haskell.~\cite{DepHaskSpec}
Dependent types provide a powerful technique for writing programs at a type-level, which
will be executed at compile-time by the type checker.~\cite{CertProg}

Additionally, features to safely convert between sensitivity levels could prove
useful. A conversion from public to secret would be straightforward. A situational conversion
going the other direction could be provided by an instruction in the EDSL
which might perform a Spectre mitigation measure, such as a cache flush. \cite{PLtea-james}

\section{Conclusion}
...
%-------------------------------------------------------------------------

\bibliographystyle{plain}
\bibliography{reference}
\end{document}
