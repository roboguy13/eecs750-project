@inproceedings{SpectreGuard,
  author = {Fustos, Jacob and Farshchi, Farzad and Yun, Heechul},
  title = {SpectreGuard: An Efficient Data-Centric Defense Mechanism against Spectre Attacks},
  year = {2019},
  isbn = {9781450367257},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/3316781.3317914},
  doi = {10.1145/3316781.3317914},
  abstract = {Speculative execution is an essential performance enhancing technique in modern processors, but it has been shown to be insecure. In this paper, we propose SpectreGuard, a novel defense mechanism against Spectre attacks. In our approach, sensitive memory blocks (e.g., secret keys) are marked using simple OS/library API, which are then selectively protected by hardware from Spectre attacks via low-cost micro-architecture extension. This technique allows microprocessors to maintain high performance, while restoring the control to software developers to make security and performance trade-offs.},
  booktitle = {Proceedings of the 56th Annual Design Automation Conference 2019},
  articleno = {61},
  numpages = {6},
  keywords = {Micro-architecture, Side-channel Attack, Spectre},
  location = {Las Vegas, NV, USA},
  series = {DAC '19}
}

@article{Lifty,
  author = {Polikarpova, Nadia and Stefan, Deian and Yang, Jean and Itzhaky, Shachar and Hance, Travis and Solar-Lezama, Armando},
  title = {Liquid Information Flow Control},
  year = {2020},
  issue_date = {August 2020},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {4},
  number = {ICFP},
  url = {https://doi.org/10.1145/3408987},
  doi = {10.1145/3408987},
  abstract = {We present Lifty, a domain-specific language for data-centric applications that manipulate sensitive data. A Lifty programmer annotates the sources of sensitive data with declarative security policies, and the language statically and automatically verifies that the application handles the data according to the policies. Moreover, if verification fails, Lifty suggests a provably correct repair, thereby easing the programmer burden of implementing policy enforcing code throughout the application. The main insight behind Lifty is to encode information flow control using liquid types, an expressive yet decidable type system. Liquid types enable fully automatic checking of complex, data dependent policies, and power our repair mechanism via type-driven error localization and patch synthesis. Our experience using Lifty to implement three case studies from the literature shows that (1) the Lifty policy language is sufficiently expressive to specify many real-world policies, (2) the Lifty type checker is able to verify secure programs and find leaks in insecure programs quickly, and (3) even if the programmer leaves out all policy enforcing code, the Lifty repair engine is able to patch all leaks automatically within a reasonable time.},
  journal = {Proc. ACM Program. Lang.},
  month = aug,
  articleno = {105},
  numpages = {30},
  keywords = {program synthesis, information flow control, liquid types}
}


@inproceedings{LightweightIF,
  author = {Russo, Alejandro and Claessen, Koen and Hughes, John},
  title = {A Library for Light-Weight Information-Flow Security in Haskell},
  year = {2008},
  isbn = {9781605580647},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/1411286.1411289},
  doi = {10.1145/1411286.1411289},
  abstract = {Protecting confidentiality of data has become increasingly important for computing systems. Information-flow techniques have been developed over the years to achieve that purpose, leading to special-purpose languages that guarantee information-flow security in programs. However, rather than producing a new language from scratch, information-flow security can also be provided as a library. This has been done previously in Haskell using the arrow framework. In this paper, we show that arrows are not necessary to design such libraries and that a less general notion, namely monads, is sufficient to achieve the same goals. We present a monadic library to provide information-flow security for Haskell programs. The library introduces mechanisms to protect confidentiality of data for pure computations, that we then easily, and modularly, extend to include dealing with side-effects. We also present combinators to dynamically enforce different declassification policies when release of information is required in a controlled manner. It is possible to enforce policies related to what, by whom, and when information is released or a combination of them. The well-known concept of monads together with the light-weight characteristic of our approach makes the library suitable to build applications where confidentiality of data is an issue.},
  booktitle = {Proceedings of the First ACM SIGPLAN Symposium on Haskell},
  pages = {13–24},
  numpages = {12},
  keywords = {library, monad, declassification, information-flow},
  location = {Victoria, BC, Canada},
  series = {Haskell '08}
}

@inproceedings{FormalIF,
  author = {Vassena, Marco and Russo, Alejandro},
  title = {On Formalizing Information-Flow Control Libraries},
  year = {2016},
  isbn = {9781450345743},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/2993600.2993608},
  doi = {10.1145/2993600.2993608},
  abstract = {Many state-of-the-art IFC libraries support a variety of advanced features like mutuable data structures, exceptions, and concurrency, whose subtle interaction makes verification of security guarantees challenging. In this paper, we present a full-fledged, mechanically-verified model of MAC---a statically enforced IFC library. We describe three main insights gained during the formalization process. As previous libraries (e.g., LIO and HLIO), we utilize term erasure as the proof technique to show non-interference. This technique essentially states that the same public output should be produced if secrets are erased before or after program execution. Our first insight identifies challenges when the sensitivity of terms may depend on the context where they are used, thus affecting how they will be erased. This situation is not uncommon in MAC as well as other IFC libraries---in fact, we spot problems in the proofs of previous work. To deal with such complicated situations, we propose a novel erasure technique that performs erasure by additional evaluation rules, triggered by special-purpose constructs. Furthermore, we simplify reasoning about exception-aware primitives by removing sensitive exceptions from programs where secrets have been erased. We show progress insensitive non-interference for our sequential calculus and pinpoint sufficient requirements on the scheduler to prove progress-sensitive non-interference for our concurrent calculus. We prove that MAC is secure under a round-robin scheduler by simply instantiating our main scheduler-parametric theorem.},
  booktitle = {Proceedings of the 2016 ACM Workshop on Programming Languages and Analysis for Security},
  pages = {15–28},
  numpages = {14},
  keywords = {haskell, non-interference, agda},
  location = {Vienna, Austria},
  series = {PLAS '16}
}

